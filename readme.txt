Техническое задание.
---------------------

Необходимо сделать виджет фильтров для товаров каталога Интернет-магазина, реализованного стандартными средствами системы управления сайтами UMI.CMS версии 2.8.5.

Список фильтров должен строится динамически, на основе указанных в настройках групп полей шаблона данных и реального наличия товаров в просматриваемой категории.
В список фильтров должны попадать поля следующих типов: "число", "число с точкой", "цена", "ссылка на дерево", "список", "кнопка-флажок".

Для отображения фильтров должны использоваться следующие типы контролов: 
1) "число", "число с точкой", "цена" - горизонтальный слайдер с возможностью ручного ввода конкретных значений
2) "ссылка на дерево", "список" - выпадающий список (стандартный html контрол select)
3) "кнопка-флажок" - чекбокс (стандартный html контрол input типа checkbox)

Должна быть возможность сворачивать и разворачивать контролы полей, а также указывать в настройках - какие из контролов должны быть развёрнуты при загрузке фильтров на странице.

При изменении набора фильтров пользователем, ему должно быть временно показано количество найденных товаров для текущего набора фильтров.
Текст должен быть следующим: "Найдено результатов: N", где N - это найденное количество товаров, удовлетворяющее текущему состоянию фильтров.
N должно быть ссылкой, по нажатию на которую будет выполняться то же действие, что и при нажатии на кнопку подтверждения фильтрации.

По мере изменения набора фильтров визуально должны отмечаться опции, при выборе которых не будет найдено ни одного товара. Такие опции должны отмечаться серым (#b0b0b0) цветом.

Кнопка подтверждения набора выбранных фильтров должна быть реализована стандартным html-контролом input типа submit.
Текст на кнопке подтверждения должен быть следующий: "Показать". По мере набора фильтров текст должен меняться, отображая количество найденных товаров. Например: "Показать 1 результат".

Для полей шаблона данных, для которых есть подсказка, в виджете должна отображаться кнопка с символом "?", по нажатию на которую пользователю будет отображено содержимое подсказки для поля шаблона данных.

Виджет фильтров по умолчанию должен обрамляться границей со скруглёнными углами (радиус 10px). В качестве цветов границы и контрола слайдера можно использовать оранжевый (#f6a828 и #FF9B00).
Однако, как цвета, так и граница должны быть модифицируемы средствами css.

При фильтрации по выбранному набору фильтров, виджет нужно делать неактивным вплоть до загрузки страницы с результатом фильтрации.

Должны быть предусмотрены настройки виджета, позволяющие указывать, с какой стороны (слева или справа) показывать подсказки для полей и количество найденных результатов.
Должно быть предусмотрено кэширование результатов запросов в БД для поиска списка доступных фильтров и количества найденных товаров для запросов пользователей. 
Должно быть предусмотрено кэширование результатов коротких (до 255 символов в строке GET-параметров) ajax-запросов виджета и возможность получения закэшированных результатов без обращения в макрос UMI.CMS.
При вставке виджета в вёрстке страницы нужно указывать идентификатор текущей категории товаров. Виджет для построения списка фильтров должен использовать тот шаблон данных, страниц которого больше всего в указанной категории.

Для реализации выборки по выбранному состоянию фильтров должен использоваться стандартный механизм UMI.CMS - GET-параметры fields_filter.
Этот механизм специально для выборки товаров по фильтрам должен быть расширен директивой IN. Для этого нужно использовать GET-параметр k_fields_filter.
В качестве страницы с результатом фильтрации необходимо использовать текущую страницу с виджетом с добавлением GET-параметров фильтрацыы (fields_filter и k_fields_filter).

Для реализации frontend части виджета необходимо использовать javascript, css и html. При запросах на backend необходимо использовать технологию ajax.
При этом, во время выполнения запросов нужно показывать анимацию, реализованную через изображение gif. При реализации javascript-кода допустимо использовать следующие библиотеки: jquery, jqueryUI, jquerytip.

Для реализации backend необходимо использовать php. Для выдачи сохранённого кэша коротких запросов необходимо реализовать правила в файле .htaccess UMI.CMS.


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


Требования:
1) Подключается на любой странице категории
2) Возможность указывать группы, откуда брать поля для фильтров (причём, по идее, в разных категориях могут быть разные поля - берётся для dominantTypeId)
3) В фильтрах должны быть только те поля, для которых реально есть товары (возможность управлять этим - типа, показывать все поля, или скрывать такие)
4) При наборе фильтров должно показываться найденное количество товаров
5) При наборе фильтров должны засериваться фильтры, для которых не будет найдено товаров
6) Возможность указывать заранее раскрытые фильтры
7) Реализация фильтрации через стандартный механизм GET-параметров fields_filter UMI.CMS
8) Расширение fields_filter директивой IN (только для фильтров)
9) Возможность отображать подсказки для полей в виджете (данные - из подсказок для полей в шаблоне данных)
10) Возможность кастомизировать, добавляя статическое условие в выборки (в фильтры)


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


Для подключения:
1. Backend.
  1.1) Разместить папку kFilters в classes/modules/catalog (так же, как она лежит тут)
  1.2) Создать кастом catalog/kfilters:
	/**
	 * Proxy for kFilters widget
	 */
	public function kfilters($sAction = false, $sCategoryId = false) {
		$sAction = ($sAction) ? $sAction : getRequest('param0');
		$sCategoryId = ($sCategoryId) ? $sCategoryId : getRequest('param1');
		
		if(!class_exists('kFilters')) require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'kfilters' . DIRECTORY_SEPARATOR . 'kFilters.php');
		
		$filtersResult = kFilters::getInstance($sCategoryId)->runAction($sAction);
		
		if(kFilters::getInstance($sCategoryId)->customLogic->saveJsonCache()) {
			kFilters::getInstance($sCategoryId)->saveJsonCache($filtersResult);
		}
		
		// Disable browser caching
		header('Cache-Control: no-cache, no-store, must-revalidate'); // HTTP 1.1.
		header('Pragma: no-cache'); // HTTP 1.0.
		header('Expires: 0'); // Proxies.
		
		return def_module::flush($filtersResult, "text/javascript");
	}
  1.3) В макросе отображения товаров (будь то кастом или системный) - надо найти место, где формируется выборка (объект класса umiSelection) и добавить туда код: 
    if(!class_exists('kFilters')) require_once(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'kfilters' . DIRECTORY_SEPARATOR . 'kFilters.php');
    kFilters::getInstance($category_id)->applyInFilters($sel);
  где $sel - это и есть объект umiSelection. Этот код позволяет реализовать условие равенства нескольким критериям через get-запрос (fields_filter)
  1.4) Надо добавить permission для кастома catalog::kfilters, доступный для всех - это макрос, на который обращается виджет с front-end-а
  1.5) В customLogic надо указать группы полей и прочие настройки данных
  1.6) В customLogic можно указать сохранение json-ответов в кэш (метод saveJsonCache). Если используется сохранение, то в основной .htaccess сайта нужно в самый веркх (сразу после RewriteEngine On) добавить правила для статического кэша:
	RewriteCond %{REQUEST_URI} ^/udata/catalog/kfilters/(.+)
	RewriteCond %{DOCUMENT_ROOT}/js/kfilters/kJsonCache/%{REQUEST_URI}/%{QUERY_STRING}/index.html -f
	RewriteRule ^(.*)$ /js/kfilters/kJsonCache/%{REQUEST_URI}/%{QUERY_STRING}/index.html [L]

2. Front-end.
  2.1) Необходимо разместить в папку js на сайте. Проект использует jquery (нет в архиве - должен быть на сайте), jqueryUI, jquery qTip
  2.2) В вёрстке надо разместить пустой div (скажем, с id=kFiltersBlock) и подключить виджет в тэге head следующим образом:
	
	<!-- kFilters includes - start -->
	<link rel="stylesheet" href="/js/jqueryui/css/ui-lightness/jquery-ui-1.8.16.custom.css" type="text/css" />
	<link rel="stylesheet" href="/js/kfilters/style.css" type="text/css" />

	<script type="text/javascript" src="/js/jqueryui/js/jquery-ui-1.8.16.custom.min.js" charset="utf-8"></script>
	<script type="text/javascript" src="/js/jqueryqtip/jquery.qtip-1.0.0-rc3.min.js" charset="utf-8"></script>
	<script type="text/javascript" src="/js/kfilters/kfilters.js" charset="utf-8"></script>

	<script type='text/javascript'>
	jQuery(document).ready(function($) {
		$.fn.qtip.styles.kTips.tip = "topRight";
		$.fn.qtip.styles.kCountTips.tip = "rightMiddle";
		$('#kFiltersBlock').kFilters({
			width: '280px',
			'min-height': '80px',
			category_id: 30318,
			tipPosition: {
				tooltip: 'topRight',
				target: 'bottomLeft'
			},
			countTipPosition: {
				target: 'leftMiddle',
				tooltip: 'rightMiddle'
			}
			//,debug: true
		});
	});
	</script>
	<!-- kFilters includes - end -->
	
3. Settings
  Виджет гибко настраивается под различные нужды, как со стороны front-end, так и со стороны backend. 
  3.1) Front-end - для стилей можно использовать /js/kfilters/style.css . Кроме того, внешний вид настраивается и в момент вызова виджета.
  Доступные опции можно увидеть в свойстве settings в файле /js/kfilters/kfilters.js (там с комментариями расписаны они). Там же есть 
  гловальные настройки для всплывающих подсказок: kTips и kCountTips (посказки, если что, берутся из базы юми из подсказок к полям в шаблонах данных)
  3.2) Back-end - кастомизация и настройки разполагаются в файле classes/modules/catalog/kFilters/kFiltersCustomLogic.php  . 
  Менять можно методы (кроме __construct). 
  В объекте доступны свойства $this->catalogId (ID категории каталога, для которой строятся фильтры) и $this->objectsTypeId (ID типа объектов каталога, преобладающих в категории (для которых строятся фильтры))
  Достпно окружение  umi.cms.
 